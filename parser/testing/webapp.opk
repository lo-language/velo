/**

    // this gets turned into a function with sig: args, next
    handler = action (err) { x = 42; };

    _handler = function (args, next) {

        var _repeat = _handler;
        _x = 42;
    };
 */
action (args, system, shop) {

    port is 8080

    port -> out

/*

    a sequence is a bunch of nonce functions

    // define the sequences
    // how to build this?
    // just create a function for the RHS?

    var a = function (message, channel) {

        var _repeat = a;
        var next = a1;


    };

    var a1 = function (message, channel) {

        var _repeat = a1;
        var next = a2;

        if (channel == OUT) {
            // pass through
            next(message, channel);
            return;
        }

        handler(message);
    };

    var a2 = function (message, channel) {

        var _repeat = a2;
        var next = blackHole;

        if (channel == ERR) {
            // break the sequence
            throw new Error();
        }
    };

    // start the sequences
    a();
    b();

    do log events flow down the chain?

    // creates a list if plural?
    shop.make(name) => thing

    create a function for the LHS
    create a function for the RHS determined by connector
    each RHS function has sig (out, err, log)

    the RHS fn is called when LHS result is available?
    have them return promises?

    call LHS(RHS)

    ~ compiles to

    function (out, err, log) {

        if (out)
        if (err) {

        }
    }


    "hello, world!\n" -> action (msg) {

        msg -> out
    }
    -> out

    expr -> action translates to

    action(expr_result,

    Q.resolve("hello, world!\n").then(
        function () {


        }
    ).then(out);


    shop.make('Http/Logger/ELF', system.stderr) => log;
    shop.make('Http/Server', log) => server;

    server.onRequest >> (request) {

        '\n' -> request.rawResponse
    }

    server.listen(port) -> {
        log.info("server running on port _port_")
    }
    ~ (err) {
        log.err("failed to open port _port_: ")
    }

    system.trap('SIGINT') -> {
        log.info("received SIGINT")
        server.stop()
    }

    */
}