/*
 * tries to find all unregistered english word domains
 *
 * for each TLD, go through every english word that ends in it, and hit whois for the word
 * if it's unregistered, print it out
 *
 * first approach: regex match
 * second approach: custom-built suffix tree
 */

// can use = as an indicator to BLOCK on the result and => as an indicator to NOT BLOCK?
// in this way, we act like a typical language? but I don't like having blocking in there at all

receive args, io, env, lib

lib.make("/dns/whois") ->

    receive whois

    // load the dictionary as an ordered list
    io.in.readLines() >>

        receive word

        // ignore words over 6 chars
        if # word > 6
            skip

        // see if word fits any TLD - could use a trie for this

        findDomains(word.lower()) >>

            receive domain

            if (checkDomain(domain))
                domain -> io.out

findDomains =

    receive word;

    ['com', 'net', 'org', 'io', 'it', 'me', 'to', 'aero', 'co'] >>

        receive tld;

        // wacky syntactic sugar here - /REGEX/ is shorthand for an action
        word -> /.+tld/ -> {
            emit(word + tld)
        }
    }
    :: {
        end();
    }
}

checkDomain = action (domain) {

    result = whois(domain)

    if result
        return result