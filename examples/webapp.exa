receive args, io, env

logger = create('Http/Logger/ELF', io.log);

handler =
    receive request;
    '\n' -> request.rawResponse;

server = obtain('Http/Server', io.port, handler, logger);

// \XXXX syntax converts ASCII to an int value - max 4 or 8 chars?
server.start() ->
    log(\info, "server running on port \_port_");
~>
    receive err;
    log(\err, "failed to start server on port \_port_: \_err_");

env.trap('SIGINT') ->
    log(\info, "received SIGINT");
    server.stop() ->
        log(\err, "server stopped");

/*

    a chain is a bunch of nonce functions

    // define the sequences
    // how to build this?
    // just create a function for the RHS?

    var a = function (message, channel) {

        var _repeat = a;
        var next = a1;


    };

    var a1 = function (message, channel) {

        var _repeat = a1;
        var next = a2;

        if (channel == OUT) {
            // pass through
            next(message, channel);
            return;
        }

        handler(message);
    };

    var a2 = function (message, channel) {

        var _repeat = a2;
        var next = blackHole;

        if (channel == ERR) {
            // break the sequence
            throw new Error();
        }
    };

    // start the sequences
    a();
    b();

    do log events flow down the chain?

    // creates a list if plural?
    shop.make(name) => thing

    create a function for the LHS
    create a function for the RHS determined by connector
    each RHS function has sig (out, err, log)

    the RHS fn is called when LHS result is available?
    have them return promises?

    call LHS(RHS)

    ~ compiles to

    function (out, err, log) {

        if (out)
        if (err) {

        }
    }


    "hello, world!\n" -> action (msg) {

        msg -> out
    }
    -> out

    expr -> action translates to

    action(expr_result,

    Q.resolve("hello, world!\n").then(
        function () {


        }
    ).then(out);


    */
}