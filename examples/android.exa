/**
 * This program is the answer to an interview question I like to ask:
 * how many valid android lockscreen patterns are there?
 *
 * Created by: spurcell
 * 12/6/2015
 */


NUM_POINTS is 9;
MIN_POINTS is 4;

// recursively iterate
// label points as 0-8

explore is -> {

    receive path;

    point = 0;
    found = 0;

    while point < NUM_POINTS {

        valid = true;

        if point in path {   // point already used
            valid = false;
        }
        // top edge
        else if path[-1] == 0 and point == 2 {
            valid = 1 in path;
        }
        else if path[-1] == 2 and point == 0 {
            valid = 1 in path;
        }
        // middle horizontal
        else if path[-1] == 3 and point == 5 {
            valid = 4 in path;
        }
        else if path[-1] == 5 and point == 3 {
            valid = 4 in path;
        }
        // bottom edge
        else if path[-1] == 6 and point == 8 {
            valid = 7 in path;
        }
        else if path[-1] == 8 and point == 6 {
            valid = 7 in path;
        }
        // left edge
        else if path[-1] == 0 and point == 6 {
            valid = 3 in path;
        }
        else if path[-1] == 6 and point == 0 {
            valid = 3 in path;
        }
        // middle vertical
        else if path[-1] == 1 and point == 7 {
            valid = 4 in path;
        }
        else if path[-1] == 7 and point == 1 {
            valid = 4 in path;
        }
        // right edge
        else if path[-1] == 2 and point == 8 {
            valid = 5 in path;
        }
        else if path[-1] == 8 and point == 2 {
            valid = 5 in path;
        }
        // diagonals
        else if path[-1] == 0 and point == 8 {
            valid = 4 in path;
        }
        else if path[-1] == 8 and point == 0 {
            valid = 4 in path;
        }
        else if path[-1] == 2 and point == 6 {
            valid = 4 in path;
        }
        else if path[-1] == 6 and point == 2 {
            valid = 4 in path;
        }

        if valid {

            // add point to path
            point -> path;

            // see if path is long enough
            if #path >= MIN_POINTS {
//                io.stdout.write("`path`\n");
                found++;
            }

            // extend the path if possible
            if #path < NUM_POINTS {
                found += explore(path);
            }

            // pop the point off the path
            path[cut -1];
        }

        point++;
    }

    reply found;
};

main is service {

    receive io, system;

    // for this problem we want a sequence, since a path has order, but we also want const time lookup of what we've used
    // we can just use a set for that

    io.out.write("`explore({})`\n");
};