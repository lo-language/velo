Exa is a simple and practical programming language intended for building secure, scalable services in the real world – where threats are pervasive, failures are commonplace and testability is essential. Despite having radically different semantics from most languages, Exa has a friendly and familiar syntax and in general has been designed with programmer happiness – presuming high productivity as a major component thereof – as its paramount objective.

The central thesis of Exa is that with proper isolation between modules, security and concurrency – those notoriously difficult aspects of software engineering utterly ignored by almost every popular language – are free. Not just easy, but an automatic consequence of modularity. This beautiful idea has been kicking around academia for decades but has never made it into widespread practice; Exa's mission is to change that.

Some highlights of Exa's design:

- Modules and objects are isolated from each other except for asynchronous messages, usually in request-response pairs.
- Failure is – finally – a clear and explicit concept: every request can succeed or fail.
- Asynchronous logic is explicit: continuations are a  distinct concept from procedures.
- All procedures can be invoked synchronously or asynchronously at the caller's discretion.

And the really big one:

- Objects are re-conceived as procedure environments rather than data structures: there are no classes, only constructors, and you can't hold a reference to an object, only an interface to it.

To learn about the language, see the [docs](docs).

#### Implementation

This is an implementation of Exa as a transpiler to JavaScript. The exa "binary" is a load-and-go compiler that can also be used to generate Node.js executables. Modules are parsed and compiled when loaded.

#### Installation

Clone the repo then in the project root folder do:

    $ npm install -g

#### To run an Exa program

    $ exa <source file>

This will compile the Exa source, load it, and run.

#### To build a Node executable

    $ exa --build <target file> <source file>

#### To run the examples

	$ cd examples
	$ exa factorial.exa 10
	3628800
	
etc.

#### To run the tests 

In the project root folder:

    $ npm test

# How it Works

#### Parsing

Scanning and parsing are handled by a parser generated by Jison.

#### Code Generation

The compiler generates JavaScript source from the AST bottom-up by snapping together chunks of JS wrapped in the following classes:

**JsConstruct**: base class for holding chunks of JS; expands helper objects such as argument lists and resolves SyncMessages when required

**SyncMessage**: models a synchronous message by wrapping supplied code in a Message

#### Runtime

The Exa runtime provides the implementation of the Exa Task tree as well as the module loader, which pulls in the parser/compiler.
