// doesn't take any input

foo is:
    fail "oh no!";

foo();


// concurrent, because we're not *using* the value
// statement, not expression
foo();

// sync - x gets its value before next line is run. nice and familiar.
// statement, not expression
x = foo();

// concurrent - x is defined as a promise before the next line is run. this is new.
// statement, not expression
foo() => x;

// sync with error handling/recovery. this is new.
x = foo() ~> handler;

foo() ~> handler => x; // concurrent with error handling
foo() => x ~> handler; // could do this order instead, which way makes more sense?

// concurrent
foo() ~>
    receive error;
    reply "ok";
=> x;

// or what about this?
// i think it breaks chaining but i think that's ok

foo() => x ~> handler;

foo() => x ~>
    receive error;
    reply "ok";

// the problem i see with above is
x = foo() + bar(); // these will be called concurrently, and there's no way to say they shouldn't be without unpacking the expression

// what if we also support this syntax?? would that be evil?
// or should we force this explicit syntax??
// concurrent - not an expression!
() -> foo;

() -> foo => x; // x becomes a promise before the next line is called; any expression using x is deferred until x is available

USING PROMISES

// can a promise can be assigned to something without being resolved? sure
// this could be pretty powerful - maybe later
() -> foo => bar[i];

// what if we check the type of x? i think that's a usage that should pend resolution - it shouldn't say "promise" or something

// but the promise can never hold an error - those are separate in exa

// waits until the given promises are resolved
// should this be await, collect?
require x,y,z;

// error handling is independent of style
// the RHS is still an expression

x = foo() ~> handler;

// don't need a semicolon if we go with a block?
x = foo() ~>
    receive error;
    reply "javelina";

() -> foo ~> handler => result;

() -> foo ~>
    receive error;
    reply "javelina";

=> result;


// can't have?
x = (y) -> foo

// or is that too restrictive? we should be more chill?

// rvalue connector lvalue connector...

5 -> foo => result;

try (x, y) -> foo:
    accept err;
    reply 'somesuch';

(a, b) -> foo: handler -> next: handler => result;

x = foo()  handler;