// sync calls

foo();
foo.bar();

x = foo();

// concurrent form
foo();

// capture the result in a future
foo() => x;

// handle success only
after bar(48):
    reply "hello";

// handle failure only
after baz(128) catch:
    reply "bummer";

// handle both success and failure
after foo(42):
    reply "yay";
catch:
    reply "darn";

//nil -> foo => x ~> bar;

// capture with failure handler
bar(foo) => baz catch:
    receive error;
    fail error;

// nested requests
// should we support pipes like 42 -> foo -> bar -> baz?
after foo(42):
    receive result;

    after bar(result):
        receive result;
        baz(result) => yarp;
    catch:
        fail "narp";
catch:
    reply "darn";

// sync form in expressions

foo(bar());

x = foo() + 7;

// assignment with handler - implemented with an ugly hack in the grammar

x = foo() catch:
    receive error;
    replace "ok";
